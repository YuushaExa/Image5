<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Item Shop Game</title>
    <style>
        canvas {
            border: 1px solid black;
            margin: 10px;
        }
        ul {
            list-style-type: none;
            padding: 0;
        }
        li {
            margin-bottom: 5px;
        }
        .clickable {
            cursor: pointer;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="600" height="300"></canvas>
    <div>
        <h3>Log</h3>
        <ul id="log"></ul>
    </div>
    <div>
        <h3>Items</h3>
        <ul id="items"></ul>
        <button id="restock">Restock Items</button>
    </div>
    <div>
        <h3>Shop Status</h3>
        <p>Money: $<span id="money">100</span></p>
        <p>Shop Reputation: <span id="reputation">100%</span></p>
        <p>Town Level: <span id="townLevel">0</span></p>
        <button id="upgradeTown">Upgrade Town</button>
        <div id="npcCount">0/5</div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const logElement = document.getElementById('log');
        const itemsElement = document.getElementById('items');
        const moneyElement = document.getElementById('money');
        const reputationElement = document.getElementById('reputation');
        const townLevelElement = document.getElementById('townLevel');
        const npcCountElement = document.getElementById('npcCount');
        const restockButton = document.getElementById('restock');
        const upgradeTownButton = document.getElementById('upgradeTown');
        const npcInfoCanvas = document.createElement('canvas');
        npcInfoCanvas.width = 100;
        npcInfoCanvas.height = 100;
        document.body.appendChild(npcInfoCanvas);
        const npcInfoCtx = npcInfoCanvas.getContext('2d');
        const gatheringZoneCanvas = document.createElement('canvas');
        gatheringZoneCanvas.width = 150;
        gatheringZoneCanvas.height = 200;
        document.body.appendChild(gatheringZoneCanvas);
        const gatheringZoneCtx = gatheringZoneCanvas.getContext('2d');

        const dungeonCanvas = document.createElement('canvas');
        dungeonCanvas.width = 1000;
        dungeonCanvas.height = 1000;
        dungeonCanvas.style.width = '500px';
        dungeonCanvas.style.height = '500px';
        document.body.appendChild(dungeonCanvas);
        const dungeonCtx = dungeonCanvas.getContext('2d');

        const churchCanvas = document.createElement('canvas');
        churchCanvas.width = 200;
        churchCanvas.height = 200;
        document.body.appendChild(churchCanvas);
        const churchCtx = churchCanvas.getContext('2d');

        let money = 100;
        let shopReputation = 100;
        let townLevel = 0;
        let maxNPCs = 5; // Initial max NPCs for town level 0
        let npcCounter = 1;
        let npcs = [];

        const tileSize = 30;
        const rows = 10;
        const cols = 20;
        const streetRow = 9;
        const shopStartCol = 10;
        const shopEndCol = 14;
        const cashierPosition = { row: 5, col: 12 };

        const tileMap = [
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 2, 1, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        ];

        const items = [
            { name: 'Potion', price: 10, defaultPrice: 10, stock: 5, sold: 0, demand: 100, effect: { hp: 100 } },
            { name: 'Sword', price: 50, defaultPrice: 50, stock: 2, sold: 0, demand: 100, effect: { attack: 10 } },
            { name: 'Shield', price: 30, defaultPrice: 30, stock: 3, sold: 0, demand: 100, effect: { defense: 5 } }
        ];

        const dungeon = {
            active: false,
            crystal: { hp: 100, x: 900, y: 900 },
            enemies: []
        };

        const renderGrid = () => {
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    if (tileMap[row][col] === 0) {
                        ctx.fillStyle = 'gray';
                    } else if (tileMap[row][col] === 1) {
                        ctx.fillStyle = 'brown';
                    } else if (tileMap[row][col] === 2) {
                        ctx.fillStyle = 'yellow';
                    }
                    ctx.fillRect(col * tileSize, row * tileSize, tileSize, tileSize);
                    ctx.strokeRect(col * tileSize, row * tileSize, tileSize, tileSize);
                }
            }
        };

        const renderItems = () => {
            itemsElement.innerHTML = '';
            items.forEach((item, index) => {
                const li = document.createElement('li');
                li.innerHTML = `${item.name} - $<span class="clickable" data-index="${index}" onclick="makeEditable(this)">${item.price}</span> (Stock: ${item.stock}) <br> Demand: ${item.demand}%`;
                itemsElement.appendChild(li);
            });
        };

        const createNPC = () => {
            if (npcs.length < maxNPCs && Math.random() * 100 < shopReputation) {
                const npc = {
                    id: npcCounter++,
                    name: `NPC#${npcCounter}`,
                    position: { row: streetRow, col: 0 },
                    state: 'walkingToShop',
                    money: 100,
                    attack: getRandomStat(),
                    defense: getRandomStat(),
                    hp: 100,
                    equipment: { weapon: null, shield: null }
                };
                npcs.push(npc);
                updateNPCCount();
            }
        };

        const getRandomStat = () => Math.floor(Math.random() * 9) + 2;

        const moveNPC = (npc) => {
            const { row, col } = npc.position;
            if (npc.state === 'walkingToShop' && col < shopStartCol - 1) {
                npc.position.col++;
            } else if (npc.state === 'walkingToShop' && row > cashierPosition.row) {
                npc.position.row--;
            } else if (npc.state === 'walkingToShop' && row < cashierPosition.row) {
                npc.position.row++;
            } else if (npc.state === 'walkingToShop' && col < cashierPosition.col) {
                npc.position.col++;
            } else if (npc.state === 'walkingToShop' && col === cashierPosition.col) {
                npc.state = 'shopping';
                purchaseItems(npc);
            } else if (npc.state === 'walkingBack' && col > 0) {
                npc.position.col--;
            } else if (npc.state === 'walkingBack' && col === 0) {
                npc.state = 'gathering';
                npc.position = { x: 10, y: npc.id * 40 + 10 };
                renderGatheringZone();
            }
        };

        const purchaseItems = (npc) => {
            items.forEach(item => {
                if (npc.money >= item.price && item.stock > 0) {
                    item.stock--;
                    npc.money -= item.price;
                    item.sold++;
                    item.demand -= 10;
                    logAction(`${npc.name} purchased ${item.name} for $${item.price}`);
                    adjustItemPrices();
                    updateMoney(item.price);
                    checkItemStock();
                    checkForTownUpgrade();
                    applyItemEffects(npc, item);
                }
            });
            npc.state = 'walkingBack';
        };

        const applyItemEffects = (npc, item) => {
            if (item.effect.hp) npc.hp += item.effect.hp;
            if (item.effect.attack) npc.attack += item.effect.attack;
            if (item.effect.defense) npc.defense += item.effect.defense;
        };

        const adjustItemPrices = () => {
            items.forEach(item => {
                if (item.demand > 100) {
                    item.price = Math.min(item.defaultPrice * 1.5, item.price * 1.1);
                } else if (item.demand < 100) {
                    item.price = Math.max(item.defaultPrice * 0.5, item.price * 0.9);
                }
            });
            renderItems();
        };

        const updateMoney = (amount) => {
            money += amount;
            moneyElement.textContent = money;
        };

        const checkItemStock = () => {
            const allOutOfStock = items.every(item => item.stock === 0);
            if (allOutOfStock) {
                restockItems();
            }
        };

        const restockItems = () => {
            items.forEach(item => {
                item.stock = Math.floor(Math.random() * 5) + 1;
                item.demand = 100;
                item.price = item.defaultPrice;
            });
            logAction('Items restocked!');
            renderItems();
        };

        const checkForTownUpgrade = () => {
            if (items.every(item => item.sold >= 3)) {
                upgradeTown();
            }
        };

        const upgradeTown = () => {
            townLevel++;
            maxNPCs += 5;
            townLevelElement.textContent = townLevel;
            logAction('Town upgraded!');
        };

        const logAction = (action) => {
            const li = document.createElement('li');
            li.textContent = action;
            logElement.appendChild(li);
        };

        const makeEditable = (element) => {
            const index = element.getAttribute('data-index');
            const input = document.createElement('input');
            input.type = 'number';
            input.value = element.textContent;
            input.addEventListener('blur', () => {
                const newPrice = parseInt(input.value, 10);
                if (!isNaN(newPrice) && newPrice > 0) {
                    items[index].price = newPrice;
                    element.textContent = newPrice;
                } else {
                    element.textContent = items[index].price;
                }
            });
            element.textContent = '';
            element.appendChild(input);
            input.focus();
        };

        const renderNPCs = () => {
            npcs.forEach(npc => {
                ctx.fillStyle = npc.state === 'walkingToShop' || npc.state === 'walkingBack' ? 'blue' : 'green';
                ctx.fillRect(npc.position.col * tileSize, npc.position.row * tileSize, tileSize, tileSize);
            });
        };

        const renderGatheringZone = () => {
            gatheringZoneCtx.clearRect(0, 0, gatheringZoneCanvas.width, gatheringZoneCanvas.height);
            npcs.filter(npc => npc.state === 'gathering').forEach(npc => {
                gatheringZoneCtx.fillStyle = 'green';
                gatheringZoneCtx.fillRect(npc.position.x, npc.position.y, tileSize, tileSize);
            });
        };

        const renderDungeon = () => {
            if (!dungeon.active) return;
            dungeonCtx.clearRect(0, 0, dungeonCanvas.width, dungeonCanvas.height);
            dungeonCtx.fillStyle = 'purple';
            dungeonCtx.fillRect(dungeon.crystal.x, dungeon.crystal.y, 30, 30);
            dungeon.enemies.forEach(enemy => {
                dungeonCtx.fillStyle = 'red';
                dungeonCtx.fillRect(enemy.x, enemy.y, 30, 30);
            });
            npcs.filter(npc => npc.state === 'dungeon').forEach(npc => {
                dungeonCtx.fillStyle = 'green';
                dungeonCtx.fillRect(npc.position.x, npc.position.y, tileSize, tileSize);
            });
        };

        const updateDungeon = () => {
            if (!dungeon.active) return;
            npcs.filter(npc => npc.state === 'dungeon').forEach(npc => {
                moveNPCInDungeon(npc);
            });
            checkDungeonCompletion();
        };

        const moveNPCInDungeon = (npc) => {
            if (npc.hp <= 0) return;
            if (npc.position.x < dungeon.crystal.x) npc.position.x += 2;
            if (npc.position.y < dungeon.crystal.y) npc.position.y += 2;
            if (npc.position.x >= dungeon.crystal.x && npc.position.y >= dungeon.crystal.y) {
                attackCrystal(npc);
            }
            dungeon.enemies.forEach(enemy => {
                if (Math.abs(npc.position.x - enemy.x) < 30 && Math.abs(npc.position.y - enemy.y) < 30) {
                    fightEnemy(npc, enemy);
                }
            });
        };

        const attackCrystal = (npc) => {
            dungeon.crystal.hp -= npc.attack;
            if (dungeon.crystal.hp <= 0) {
                logAction('Crystal destroyed!');
                npcs.filter(npc => npc.state === 'dungeon').forEach(npc => {
                    npc.money += 100;
                    moveNPCBackToShop(npc);
                });
                dungeon.active = false;
            }
        };

        const fightEnemy = (npc, enemy) => {
            enemy.hp -= npc.attack;
            npc.hp -= enemy.attack;
            if (enemy.hp <= 0) {
                npc.money += 50;
                dungeon.enemies = dungeon.enemies.filter(e => e.id !== enemy.id);
            }
            if (npc.hp <= 0) {
                npc.state = 'dead';
                moveNPCToChurch(npc);
            }
        };

        const moveNPCToChurch = (npc) => {
            npc.position = { x: 10, y: npc.id * 40 + 10 };
            renderNPCInChurch(npc);
            setTimeout(() => {
                npc.hp = 100;
                npc.state = 'walkingToShop';
                renderChurch();
            }, 60000); // Resurrect after 1 minute
        };

        const renderNPCInChurch = (npc) => {
            churchCtx.fillStyle = 'green';
            churchCtx.fillRect(npc.position.x, npc.position.y, tileSize, tileSize);
        };

        const renderChurch = () => {
            churchCtx.clearRect(0, 0, churchCanvas.width, churchCanvas.height);
            npcs.filter(npc => npc.state === 'dead').forEach(npc => {
                renderNPCInChurch(npc);
            });
        };

        const checkDungeonCompletion = () => {
            if (dungeon.crystal.hp <= 0) {
                npcs.filter(npc => npc.state === 'dungeon').forEach(npc => {
                    npc.money += 100;
                    moveNPCBackToShop(npc);
                });
                dungeon.active = false;
            }
        };

        const moveNPCBackToShop = (npc) => {
            npc.state = 'walkingBack';
        };

        const startDungeon = () => {
            dungeon.active = true;
            dungeon.crystal.hp = 100;
            createEnemies();
            renderDungeon();
        };

        const createEnemies = () => {
            dungeon.enemies = [];
            const enemyCount = Math.floor(Math.random() * 7) + 4; // 4-10 enemies
            for (let i = 0; i < enemyCount; i++) {
                dungeon.enemies.push({
                    id: i,
                    hp: 30,
                    attack: getRandomStat(),
                    defense: getRandomStat(),
                    x: Math.floor(Math.random() * 900),
                    y: Math.floor(Math.random() * 900)
                });
            }
        };

        const checkGatheringZone = () => {
            const gatheringNPCs = npcs.filter(npc => npc.state === 'gathering');
            if (gatheringNPCs.length >= 5) {
                startDungeon();
                gatheringNPCs.forEach(npc => {
                    npc.state = 'dungeon';
                    npc.position = { x: 0, y: 0 };
                });
                renderDungeon();
            }
        };

        const updateNPCCount = () => {
            npcCountElement.textContent = `${npcs.length}/${maxNPCs}`;
        };

        restockButton.addEventListener('click', restockItems);
        upgradeTownButton.addEventListener('click', upgradeTown);

        setInterval(() => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            renderGrid();
            renderItems();
            npcs.forEach(moveNPC);
            renderNPCs();
            renderGatheringZone();
            updateDungeon();
            renderChurch();
            checkGatheringZone();
        }, 1000);
    </script>
</body>
</html>
